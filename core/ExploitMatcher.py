import re

from config import exploit_search_config
from entities.Exploit import Exploit
from entities.Properties import Rank
from inout.CVEDetailParser import CVEDetailParser
from inout.ConsoleHandler import ConsoleHandler


class ExploitMatcher:

    def __init__(self, db_handler):
        self.console = ConsoleHandler("ExplMatcher")
        self.db_handler = db_handler

    def find_exploits_for_vuln(self, vuln, os, os_multi, rank):
        matching_expl = self.get_all_exploits_for_name(vuln.name, os, os_multi) + \
                        self.find_exploits_by_cve(vuln.cve) + \
                        self.find_exploits_by_bid(vuln.bid)
        if len(matching_expl) > 0:
            matching_expl = self.remove_duplicates(matching_expl)
            matching_expl = self.filter_by_os(os, os_multi, matching_expl)
            self.console.info("Filtered exploits by OS '{}': {} left.".format(os, len(matching_expl)))
            matching_expl = self.filter_by_rank(rank, matching_expl)
            self.console.info("Filtered exploits by Rank '{}': {} left.".format(rank, len(matching_expl)))
            matching_expl = self.sort_exploits(matching_expl)
        return matching_expl

    def find_exploits_by_cve(self, cve):
        cves = CVEDetailParser.parse_cves(self.console, cve)
        cve_expl = []
        self.console.info("Searching by CVEs {}".format(cves))
        if len(cves) > 0:
            for cve in cves:
                expl_list = self.get_all_exploits_for_cve(cve)
                if expl_list is not None:
                    cve_expl.append(expl_list)
        if len(cve_expl) == 0:
            self.console.warn("\t None found.")
        return cve_expl

    def find_exploits_by_bid(self, bid_str):
        bids = CVEDetailParser.parse_bids(bid_str)
        bid_expl = []
        self.console.info("Searching by BIDs {}".format(bids))
        if len(bids) > 0:
            for bid_str in bids:
                expl = self.get_all_exploits_for_bid(bid_str)
                if expl is not None:
                    bid_expl.append(expl)
        if len(bid_expl) == 0:
            self.console.warn("\t None found.")
        return bid_expl

    # actually perform search for exploits by CVE
    def get_all_exploits_for_cve(self, cve):
        expl_list = self.db_handler.search_by_cve(cve)
        if len(expl_list) > 0:
            self.console.info("\t Found {} exploit(s).".format(len(expl_list)))
            return expl_list
        return None

    # actually perform search for exploits by BID
    def get_all_exploits_for_bid(self, bid):
        if bid == '':
            return None
        expl_list = self.db_handler.search_by_bid(bid)
        if len(expl_list) > 0:
            self.console.info("\t Found {} exploit(s).".format(len(expl_list)))
            return expl_list
        return None

    # actually perform search for exploits by vulnerability name
    def get_all_exploits_for_name(self, name, os, multi):
        search_name = Exploit.improve_name(name)
        self.console.info("Searching by keywords '{}'".format(search_name))
        expl_list = self.db_handler.search_by_name(search_name)
        expl_list = list(filter(lambda expl: expl.score >= exploit_search_config.get('min_score'), expl_list))
        expl_list.sort(key=lambda x: float(x.score), reverse=True)
        if len(expl_list) > exploit_search_config.get('max_count_by_name'):
            self.console.debug("found too many exploits, only use the {} with the highest score.".format(
                exploit_search_config.get('max_count_by_name')))
            expl_list = self.filter_by_os(os=os, multi=multi, expl_list=expl_list)
            expl_list = expl_list[:exploit_search_config.get('max_count_by_name')]
        for expl in expl_list:
            self.console.debug(
                "\t \t score: {}, path: '{}', title: '{}'".format(expl.score, expl.path, expl.search_name))
        if len(expl_list) > 0:
            self.console.info("\t Found {} exploit(s).".format(len(expl_list)))
        else:
            self.console.warn("\t None found.")
        return expl_list

    # extrahiere Versionsnummer aus String, findet Nummern mit bis zu dreistufiger Hierarchie
    @staticmethod
    def get_version_number(str):
        pattern = "(\d)+.(\d)(.(\d)+)?"
        match = re.search(pattern, str)
        if match is None:
            return None
        return match.group(0)

    # removes all duplicates from a nested list of exploit objects
    def remove_duplicates(self, expl_lists):
        if expl_lists is None:
            return None
        expl_list = Exploit.flatten_expl_lists(expl_lists)
        filtered_expl_list = []
        for expl in expl_list:
            unique = True
            for filtered_expl in filtered_expl_list:
                if expl.path == filtered_expl.path:
                    unique = False
            if unique:
                filtered_expl_list.append(expl)
        self.console.info("Removed {} duplicate exploits.".format(len(expl_list) - len(filtered_expl_list)))
        return filtered_expl_list

    # filter the given list of exploits by operating system
    def filter_by_os(self, os, multi, expl_list):
        if os == 'all':
            return expl_list
        if os == 'linux':
            if multi:
                return list(
                    filter(lambda expl: (expl.os == 'linux' or expl.os == 'unix' or expl.os == 'multi'), expl_list))
            return list(filter(lambda expl: (expl.os == 'linux' or expl.os == 'unix'), expl_list))
        elif os == 'windows':
            if multi:
                return list(filter(lambda expl: (expl.os == 'windows' or expl.os == 'multi'), expl_list))
            return list(filter(lambda expl: expl.os == 'windows', expl_list))
        else:
            return []

    # filter the given list of exploits by a minimum reliability ranking
    def filter_by_rank(self, rank, expl_list):
        return list(filter(lambda expl: self.compare_rankings(expl.rank, rank), expl_list))

    # compare a given rank of a exploit to the demanded minimum rank
    def compare_rankings(self, rank, min_rank):
        return Rank.value_from_str(rank) >= Rank.value_from_str(min_rank)

    # sort exploits by the msf module rank attribute
    def sort_exploits(self, expls):
        if len(expls) == 0:
            return []
        expls.sort(key=lambda x: Rank.value_from_str(x.rank), reverse=True)
        self.console.info("Sorted exploits.")
        return expls
