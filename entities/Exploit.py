import re
from dataclasses import dataclass, asdict
from enum import Enum
from typing import List

from dacite import from_dict

common_params = ['RHOST', 'RHOSTS', 'RPORT']
critical_params = ['TARGETURI', 'URI', 'USERNAME', 'USERPASS', 'PASSWORD', 'HttpPassword', 'HttpUsername', 'SMBUser',
                   'SMBPass', 'FORM_PATH']

TAGS_TO_REMOVE = ['and', 'or', 'of', 'vulnerability', 'vulnerabilities', 'multiple', 'windows', 'linux', 'when']
CHARS_TO_REMOVE = ['(', ')']


@dataclass
class Exploit:
    path: str
    full_name: str
    search_name: str
    os: str
    rank: str
    cve: str
    bid: str
    all_params: List[str]
    req_params: List[str]
    score: float

    def to_dict(self):
        if self.cve is not '':
            self.cve = "CVE-" + self.cve
        return asdict(self)

    @staticmethod
    def from_dict(expl_dict):
        return from_dict(data_class=Exploit, data=expl_dict)

    def print_short(self):
        return self.path

    def get_non_common_params(self):
        return list(set(self.all_params).intersection(critical_params))

    def contains_required_param(self, param_name):
        return param_name in self.req_params

    @staticmethod
    def print_expl_list(exploits):
        name_list = ""
        for i, _ in enumerate(exploits):
            if i == 0:
                name_list = exploits[i].print_short()
            else:
                name_list += (", {}".format(exploits[i].print_short()))
        return name_list

    @staticmethod
    def dicts_to_expls(dicts):
        exploits = []
        for dict in dicts:
            exploits.append(Exploit.from_dict(dict))
        return exploits

    # takes a nested lits of exploits and returns an one-dimensional one
    @staticmethod
    def flatten_expl_lists(lists):
        expl_list = []
        for elem in lists:
            if isinstance(elem, Exploit):
                expl_list.append(elem)
            else:
                for elem in elem:
                    expl_list.append(elem)
        return expl_list

    @staticmethod
    def improve_name(name):
        search_name = Exploit.remove_disturbing_chars(name)
        # remove version numbers because they tamper with the score
        search_name = re.sub("(v)?\d(.\d)?(.\d)?", "", search_name).strip()
        search_name = search_name.lower().split(' ')
        for tag in TAGS_TO_REMOVE:
            if tag in search_name:
                search_name.remove(tag)
        return ' '.join(search_name)

    @staticmethod
    def remove_disturbing_chars(name):
        for char in CHARS_TO_REMOVE:
            name = name.replace(char, '')
        return name


class ExploitClass(Enum):
    NOT_INTRUSIVE = 0
    INTRUSIVE = 1
    INTRUSIVE_DESTRUCTIVE = 2

    @staticmethod
    def from_str(name):
        try:
            return ExploitClass[name.upper().strip()]
        except KeyError:
            raise KeyError('no such exploit classification exists.')


@dataclass
class ExploitClassification:
    expl_path: str
    classification: ExploitClass

    def to_dict(self):
        return {'expl_path': self.expl_path, 'class': self.classification}


class ExplExecDetectionMethod(Enum):
    NONE = 0  # No exploit execution has been detected
    BIND_PAYLOAD_CONNECTION = 1  # Connection to bind payload has been established
    PAYLOAD_STAGE_REQUEST = 2  # Payload Dropper has sent the request for the second stage
    PAYLOAD_STAGE_CONNECTION = 3  # Payload Dropper has established a reverse connection to the host
    REVERSE_PAYLOAD_REQUEST = 4  # Payload has send the reverse request to the host
    REVERSE_PAYLOAD_CONNECTION = 5  # Payload has established a reverse connection to the host
    DETECTED_SHELL = 6  # A remote shell has been successfully opened
    COMMUNICATED_WITH_SHELL = 7  # Communication with the remote shell has been successful (at least one command has been executed)
    POSITIVE_EXEC_OUTPUT = 8  # The execution output of the exploit did not show any entries that indicate a failure
